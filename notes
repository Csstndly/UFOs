#Functions
    #undefined is a sign that function is gtg

#Takes two numbers and adds them
function addition(a, b) {
  return a + b;
}

console.log(addition(4, 5));

## Functions can call other functions
function doubleAddition(c, d) {
  var total = addition(c, d) * 2;
  return total;
}

# Arrow functions are similar to og functions but more concise
// Simple JavaScript log statement
function printHello() {
  return "Hello there!";
}

            #VS

printHello = () => "Hello there!";


# Example 2

#Original doubleAddition function
function doubleAddition(c, d) {
  var total = addition(c, d) * 2;
  return total;
}

            #VS

doubleAddition = (c, d) => addition(c, d) * 2;


#Loops

let friends = ["Sarah", "Greg", "Cindy", "Jeff"];

function listLoop(userList) {
   for (var i = 0; i < userList.length; i++) {
     console.log(userList[i]);
   }
}

# loop syntax: for (var i = 0; i < userList.length; i++) { console.log(userList[i]); }
        #vs
#python syntax: for i in user_list: print(i)

var vegetables = ["Carrots", "Peas", "Lettuce", "Tomatoes"];

for (var i = 0; i < vegetables.length; i++) {
    console.log("I love " + vegetables[i]);
}

#Example 3
for (var i = 0; i < 5; i++) {
   console.log("I am " + i);
}


## Assignment

// Using this to convert data.js array into a HTML table

// Import Data (data.js); const var so no reassiging or defining
const tableData = data;

// Reference the HTML table using d3; var as tbody tag as data will be displayed as a table;
//d3.select so JS will for <tbody>
var tbody = d3.select("tbody");

//for the project the code will function will be used to fill the table with data only.

// Create the function and pass in "data" above

function buildTable(data) {

}

// Adding to function so that the code will clear existing data, so users won't end up with pre-filtered data.

//Clearing the existing data creates a fresh table in which we can insert data. If we didn't clear existing data first,
//then we would find ourselves reinserting data that already exists, thus creating duplicates and making a bit of a mess
//It's good practice to clear the existing data first to give ourselves a clean slate to work with.

function buildTable(data) {
  tbody.html(""); //tells js to use an empty string when creating table/ create a blank canvas. References html
}


//This function builds the table/adding data to the table.

//forEach loop works only with arrays and usable with arrow function
// syntax: varname.forEach(callback function)
//callback function can be a anonymous funct, named funct, or arrow funct


  data.forEach((dataRow) => {
//data = object referencing data being imported
//forEach = keyword creating a loop
//dataRow = parameter that will be used as a value when the function is called
    });


//Tells js to find tbody tag in HTML and add a table row/tr
  data.forEach((dataRow) => {
    let row = tbody.append("tr");

    });


//Object.values = to reference 1 object from the array
//dataRow = argument stating to put the values in dataRow
//val = argument representing each item in the object, i.e location, shape, duration
data.forEach((dataRow) => {
   let row = tbody.append("tr");
   Object.values(dataRow).forEach((val) => {
});

    });

// Append each value of the object to a cell in the table.
// let cell = created variable to appending data  into a table data tag "td"
// cell.text(val) = variable that holds only each value from the object.
  data.forEach((dataRow) => {
    let row = tbody.append("tr");
    Object.values(dataRow).forEach((val) => {
      let cell = row.append("td");
      cell.text(val);
      }
    );
  });

//NEATER VERSION
function buildTable(data) {
  // First, clear out any existing data
  tbody.html("");

  // Next, loop through each object in the data
  // and append a row and cells for each value in the row
  data.forEach((dataRow) => {
    // Append a row to the table body
    let row = tbody.append("tr");

    // Loop through each field in the dataRow and add
    // each value as a table cell (td)
    Object.values(dataRow).forEach((val) => {
      let cell = row.append("td");
      cell.text(val);
      }
    );
  });
}

// ADDING FILTERS

//Set up function and variables to hold dates for filtering
function handleClick() {
    //d3.select("#datetime") = d3 will search for datetime id in HTML tags
    //.property("value") = d3 search for where date values are stored on webpage but to grab the info and hold it var
    let date = d3.select("#datetime").property("value");


// Set a default filter and save to new var
let filteredData = tableData; // setting new var to tabledata up top to use as a blank slate.Run when filter button clicked

//ADDING IF STATEMENT

// syntax : if ( condition ) { code to execute }

// pseudocode practice
if (a date is entered) {
    Filter the default data to show only the date entered
};

// Applying a filter method that will match the datetime value to the filtered date value.
if (date) {
    filteredData = filteredData.filter(row => row.datetime === date);
};


//Call the function build the filtered table
buildTable(filteredData);


// NEATER VERSION
function handleClick() {
  // Grab the datetime value from the filter
  let date = d3.select("#datetime").property("value");
  let filteredData = tableData;

   // Check to see if a date was entered and filter the
  // data using that date.
  if (date) {
    // Apply `filter` to the table data to only keep the
    // rows where the `datetime` value matches the filter value
    filteredData = filteredData.filter(row => row.datetime === date);
  };

   // Rebuild the table using the filtered data
  // @NOTE: If no date was entered, then filteredData will
  // just be the original tableData.
  buildTable(filteredData);
};

//ADDING A LISTEN TO CLICK FUNCTION
    //linking code to filter button
    //d3 will execute handleClick function wheen the button with an id of filter-btn is clicked
d3.selectAll("#filter-btn").on("click", handleClick);

// NEATER VERSION

function handleClick() {
  // Grab the datetime value from the filter
  let date = d3.select("#datetime").property("value");
  let filteredData = tableData;

   // Check to see if a date was entered and filter the
  // data using that date.
  if (date) {
    // Apply `filter` to the table data to only keep the
    // rows where the `datetime` value matches the filter value
    filteredData = filteredData.filter(row => row.datetime === date);
  }

   // Rebuild the table using the filtered data
  // @NOTE: If no date was entered, then filteredData will
  // just be the original tableData.
  buildTable(filteredData);
}

// Attach an event to listen for the form button
d3.selectAll("#filter-btn").on("click", handleClick);

// Build the table when the page loads
buildTable(tableData);




// Built a functional table with the ability to filter as well.